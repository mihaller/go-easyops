
syntax = "proto3";

option java_generic_services = true;
option java_multiple_files = true;
option java_outer_classname = "RegistryProto";
/*
 do not change the package name
 rpc clients refer to the service by package name,
 so if you change this, you need to change ALL clients
 at the same time
*/
package registrar; // DO NOT CHANGE THIS
option java_package = "net.conradwood.golang.apis.registry";

import "golang.conradwood.net/apis/common/common.proto";

enum Apitype {
  status = 0;
  grpc = 1;
  json = 2;
  html = 3;
  tcp = 4;
}

message ServiceDescription {
  string Name = 1;
  string Gurupath = 2;
}

// on a given port, we can have multiple apis
message ServiceAddress {
  string Host = 1;
  int32 Port = 2;
  repeated Apitype ApiType = 3;
  // true if this address is filtered
  // also see "ShowFiltered" in ListRequest Message
  bool Filtered = 4;
}

message ServiceLocation {
  ServiceDescription Service = 1;
  repeated ServiceAddress Address = 2;
}

message GetRequest {
  ServiceDescription Service = 1;
}
message GetResponse {
  ServiceDescription Service = 1;
  ServiceLocation Location = 2;
  string ServiceID = 3;
  string YourIP = 4; // ip of the client who called this (for matching if one
                     // wants to find, e.g. the nearest one)
}
message ShutdownRequest {
  string ServiceName = 1;
}
message ListResponse {
  repeated GetResponse Service = 3;
}
message EmptyResponse {
}
message ListRequest {
  // optional - if set filter by Name
  string Name = 1;
  bool ShowFiltered = 2;
  // optional - fuzzy filter by multiple names
  // this is meant to be helpful for Command line applications
  // idiomatic way: LookupRequest{NameMatches: flag.Args()}
  repeated string NameMatches = 3;
}

message DeregisterRequest {
  string ServiceID = 1;
}

message GetTargetRequest {
  // use either gurupath or name - not both
  string Gurupath = 1;
  string Name = 2;
  Apitype ApiType = 3;
}

message ProcessShutdownRequest {
  // optional, if nil use originators ip
  string IP = 1;
  // list all the ports we just shutdown...
  repeated int32 Port = 2;
}

message HideUpdateRequest {
  string IP = 1;
  bool Enable = 2;
}

message HideServiceRequest {
  ServiceAddress Address = 1;
  // setting this to 0 will effectively remove the hiding again
  int32 TimeoutSeconds = 2;
}

message ByIPPortRequest {
  string Address = 1;
  uint32 Port = 2;
  bool ShowFiltered = 3;
}
message ByIPPortResponse {
  ServiceDescription Service = 1;
  repeated Apitype ApiType = 2;
  bool Filtered = 3;
}

service Registry {
  // deregister a service
  rpc DeregisterService(DeregisterRequest) returns (EmptyResponse);
  // register a service at a given location
  rpc RegisterService(ServiceLocation) returns (GetResponse);
  // give me one of the instances for a given service
  rpc GetServiceAddress(GetRequest) returns (GetResponse);
  // give me all services
  rpc ListServices(ListRequest) returns (ListResponse);
  // stop a service
  rpc ShutdownService(ShutdownRequest) returns (EmptyResponse);
  // get all instances of a service
  rpc GetTarget(GetTargetRequest) returns (ListResponse);
  // this is called, by the autodeployer if it detects a shutdown process
  // essentially the ports and ip will be deregistered
  rpc InformProcessShutdown(ProcessShutdownRequest) returns (EmptyResponse);
  // "hide" a host (services on that host will no longer be included
  // in the response of ListServices() or GetTarget() )
  rpc HostHiddenStatus(HideUpdateRequest) returns (common.Void);
  // hide a service.
  // useful during upgrades, so that older instances
  // are hidden from the loadbalancer and shutdown
  // eventually
  // returns list of hidden services
  // (service will no longer be included
  // in the response of ListServices() or GetTarget() )
  rpc HideService(HideServiceRequest) returns (ServiceLocation);
  rpc ByIPPort(ByIPPortRequest) returns (ByIPPortResponse);
}
